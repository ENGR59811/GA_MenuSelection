# =============================================================================
# % Written by Olga Chsherbakova
# % City College of New York, CUNY
# % Date: August, 2023
# =============================================================================

#  KNAPSACK PROBLEM DESCRIPTION:
#  Given a knapsack with a maximum capacity of W and a set of items
#  of varying weights and values, select the items to place into the 
#  knapsack such that the total value of the selected items is maximized
#  without exceeding the weight limit W.

from deap import base, creator, tools, algorithms
import random
import pandas as pd
import numpy as np

# class provides methods for setting up and running the genetic algorithm 
# for solving the knapsack problem with given constraints.
class GeneticOptimizerKP:
    
    # Initialization
    # The __init__ method takes the calorie_capacity and items_file as 
    # parameters.  It initializes attributes for storing parameters, data and 
    # tool configurations.
    def __init__(self, calorie_capacity, items_file):
        self.calorie_capacity = calorie_capacity
        self.items_file = items_file
        self.items_df = None
        self.chromosome_length = None
        self.A = None
        self.b = None
        self.toolbox = None
        self.best_chromosome = None
        
        # use del statement to remove previously created individuals (if any)
        if hasattr(creator, "Fitness"):
            del creator.Fitness
        if hasattr(creator, "Individual"):
            del creator.Individual
            
    def _init_toolbox(self):
        # Create a Fitness class inheriting with a single weight (1.0)
        creator.create("Fitness", base.Fitness, weights=(1.0,))
        # Create an Individual class inheriting from list with a 
        # fitness attribute
        creator.create("Individual", list, fitness=creator.Fitness)
                
        # register functions needed for GA  
        self.toolbox = base.Toolbox()
        #generate a random integer (either 0 or 1) and 
        #represents a possible value for a gene in the chromosome.
        self.toolbox.register("attr_bool", random.randint, 0, 1)
        #function is used to create an individual for the genetic algorithm.
        self.toolbox.register("individual",
             #initializes a sequence with repeated values generated by 
             # another function.
             tools.initRepeat,
             # create an individual for the class
             creator.Individual,
             # generate the values for the codons of an individual
             self.toolbox.attr_bool,
             # specify number of codons an individual has, based on the 
             # chromosome_length
             n=self.chromosome_length)
        # create a population of individuals for the genetic algorithm
        self.toolbox.register("population", tools.initRepeat,
                              list, self.toolbox.individual)
        # evaluate the fitness of an individual 
        self.toolbox.register("evaluate", self.fit_func)
        # adds a penalty to the fitness score of individuals that 
        # does not satisfy the constraint. 
        self.toolbox.decorate("evaluate",
                              tools.DeltaPenalty(self.validate, -1.0))
        # registers a crossover function
        self.toolbox.register("mate", tools.cxOnePoint)
        # performs bit-flip mutation. The indpb parameter specifies 
        # the probability of each bit in the chromosome being flipped.
        self.toolbox.register("mutate", tools.mutFlipBit, indpb=0.01)
        # function from deap, performs tournament selection. 
        # tournsize specifies the number of individuals for a tournament.
        self.toolbox.register("select", tools.selTournament, tournsize=5)

    # fit_func is the fitness function that will be minimized by GA. 
    # fit_func returns the negative of the sum of the value
    # in fit_func: input is the chromosome, 
    # funcion: -(chromosome * items_table.value)
    def fit_func(self, chromosome):
        return np.dot(chromosome, self.items_df['Protein']),
    
    # validate function receives a chromosome as an input and returns True
    # if it is a valid chromosome, otherwise it returns False
    #
    # validity is tested with the inequality: A*chromosome <= b
    def validate(self, chromosome):
        return np.dot(self.A, chromosome) <= self.b
    
    # chromosome for the GA will be a vector of binary digits, where 
    # each bit represents the selection of a paticular item:
    #    - 0 if the item is NOT selected
    #    - 1 if the item is selected
    # chromosome length is the number of items in iventory
    # example:
    #   [1 0 1 0 0 0 0 0 1 1 ] - this chromosome represents a set of 10 items 
    # out of which four items are selected

    def fit(self):
        # load the items from a csv file and store it into a table
        self.items_df = pd.read_csv(self.items_file) 
        # set the length of the chromosome to the number of items
        self.chromosome_length = len(self.items_df) 
        
        # A and b are used to apply the following constraint on GA:
        # A*chromosome <= b
        # Set A to the vector of calories and b to the calorie capacity:
        self.A = self.items_df['Calories']
        self.b = self.calorie_capacity

        self._init_toolbox()
        
        # create an initial population with 20 individuals
        pop = self.toolbox.population(n=20)
        # HallOfFrame class is used to store the best individuals found during 
        # the evolution process. Creating it with a capacity of 1, 
        # which means it will store the single best individual.
        self.best_chromosome = tools.HallOfFame(1)
        
        # cxpb=0.7: The prob of performing crossover between individuals,
        # which means there is a 70% chance to perform crossover.
        # mutpb=0.2: The prob of performing mutation for each codon,
        # which means there is a 20% chance of mutation for each codon.
        # ngen=50: The number of generations or iterations for which the 
        # algorithm will run.
        # HallOfFame object where the best individuals will be stored.
        # verbose=False: This parameter determines whether the algorithm 
        # progress details are displayed.
        algorithms.eaSimple(pop, self.toolbox, cxpb=0.7, mutpb=0.2, ngen=50,
                            halloffame=self.best_chromosome, verbose=False)

        # the best individual from best_chromosome[0] to retrieve which  
        # represents the best solution that the algorithm converged to.
        # self.best_chromosome[0][0] = 1
        # self.best_chromosome[0][1] = 1
        # self.best_chromosome[0][2] = 1
        # self.best_chromosome[0][3] = 1
        # self.best_chromosome[0][4] = 1
        
        if self.validate(self.best_chromosome[0]):
            selection = self.best_chromosome[0]
        else: # if not valid, make all choices zero:
            selection = [0] * self.chromosome_length

        selection_df = self.items_df[np.array(selection, dtype=bool)]

        print('******************** GA FINISHED ********************')
        print("OPTIMAL SELECTION OF ITEMS: {}".format(
            list(selection_df['Name'])))
        print("TOTAL PROTEIN VALUE OF SELECTION: {}" .format(
            selection_df['Protein'].sum()))
        print("TOTAL CALORIE OF SELECTION: {}" .format(
            selection_df['Calories'].sum()))

# calorie_capacity = 298 # user input; max calorie carried by knapsack;
calorie_capacity = 298
items_file = 'items2.csv' #user input; data file
optimizer = GeneticOptimizerKP(calorie_capacity, items_file)
print(f'*********** READING ITEMS FROM {items_file} ************')
print(f'CALORIE LIMIT IS SET TO {calorie_capacity}')
optimizer.fit()
